[{"categories":null,"content":"하나의 맥북에서 두 개의 깃헙 계정을 사용하는 방법에 대한 정리","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"하나의 맥북에서 두 개의 깃헙 계정을 사용하는 방법에 대한 정리 하나의 맥북에서 다른 두 개의 깃헙 계정을 사용해 푸시를 하고 싶은 상황이 생겨 알아보니 ssh-key를 사용하면 가능하였다. ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:0:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"1. ssh-key 생성하기 $ cd ~/.ssh $ ssh-keygen -t rsa -C \"{github 계정 이메일}\" Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): {key 이름 지정} $ ls -rw------- 1 hongseokjun staff 411B 3 7 00:35 id_rsa_work -rw-r--r-- 1 hongseokjun staff 102B 3 7 00:35 id_rsa_work.pub -rw------- 1 hongseokjun staff 411B 3 7 00:35 id_rsa_persnal -rw-r--r-- 1 hongseokjun staff 102B 3 7 00:35 id_rsa_persnal.pub ~/.ssh 디렉토리로 이동 후 두 번째 명령어를 실행하고 {key 이름 지정} 부분에 원하는 key 이름을 입력해준다. (ex. id_rsa_work) 위의 과정을 필요한 계정만큼 반복한다. (여기서는 두 개를 예로 듦.) 끝이나면 id_rsa_work, id_rsa_work.pub, id_rsa_persnal, id_rsa_persnal.pub라는 이름의 파일들이 생성된 것을 확인한다. ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:1:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"2. ssh-agent에 ssh-key 등록 $ ssh-add -K ~/.ssh/id_rsa_work $ ssh-add -K ~/.ssh/id_rsa_persnal ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:2:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"3. GitHub에 공개키 등록 로컬에서 생성한 공개키를 복사한다. $ pbcopy \u003c ~/.ssh/id_rsa_work.pub github에 ssh-key에 해당하는 계정으로 로그인 github 계정의 settings - SSH and GPG keys 메뉴를 클릭한다. New SSH key를 클릭 title에는 key에 대한 이름을 지정하고 key에 1번에서 복사한 내용을 붙여넣어 준다. 필요한 계정만큼 반복해준다. ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:3:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"4. ssh config $ cd ~/.ssh $ vi config # 없다면 생성 # 아래 내용을 입력 Host github.com-work HostName github.com User work IdentityFile ~/.ssh/id_rsa_work Host github.com-persnal HostName github.com User persnal IdentityFile ~/.ssh/id_rsa_persanl Host : 저장소를 구분하는 일종의 key IdentityFile : ssh-key를 지정 ssh 테스트 해보기 $ ssh -T git@github.com-work Hi {GithubID}! You've successfully authenticated, but GitHub does not provide shell access. 아래 문구가 뜬다면 정상이다. ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:4:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"5. 특정 프로젝트의 git config $ vi {프로젝트}/.git/config ... [user] email = {푸시할 계정의 이메일} git의 global config가 설정되어있는 경우, 위와 같은 설정을 해주어야 해당 계정으로 푸시를 할 수 있음. ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:5:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"6. remote 설정 github에서 git ssh로 clone을 받을 수 있다. : git@github.com:work/{프로젝트}.git 또는 이미 remote가 지정되어 있는 상태라면 아래 명령어를 통해 ssh로 바꿀 수 있다. $ git remote set-url origin git@github.com:work/{프로젝트}.git 참고 https://docs.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent https://velog.io/@sonypark/GitHubSSH%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4-%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-%EA%B9%83%ED%97%88%EB%B8%8C-%EA%B3%84%EC%A0%95-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-6mk3iesh0u ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:6:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"Python의 Docstring과 Annotation에 대한 정리","date":"2021-03-06","objectID":"/docstring%EA%B3%BC_annotation/","tags":["Python"],"title":"[Python]Docstring과Annotation","uri":"/docstring%EA%B3%BC_annotation/"},{"categories":null,"content":"Python의 Docstring과 Annotation에 대한 정리 훌륭한 코드는 그 자체로 (주석이 없어도) 자명하지만 문서화 또한 잘 되어있어야한다. 문서화라고해서 주석이 주렁주렁 달린 코드를 말하는 것이 아닌 문서화를 통해 데이터 타입이 무엇인지 설명하고 때에따라 예제를 제공하는 것을 목표로 한다. ","date":"2021-03-06","objectID":"/docstring%EA%B3%BC_annotation/:0:0","tags":["Python"],"title":"[Python]Docstring과Annotation","uri":"/docstring%EA%B3%BC_annotation/"},{"categories":null,"content":"Docstring Docstring은 소스코드에 포함된 문서라고 말할 수 있으며, 기본적으로 리터럴 문자열로 구성되며 로직의 일부분을 문서화하기 위해 코드 어딘가에 배치된다. 파이썬의 경우 동적 타이핑을 하기 때문에 함수의 입력과 출력을 문서화하여 사용자가 사용할 때 함수가 어떻게 동작하는지 이해하기 쉽게끔 docstring으로 문서화를 하는 것이 코드의 동작을 이해하는데 큰 도움이 될 수 있다. 따라서 Docstring을 아래와 같이 정리해 볼 수 있다. Docstring은 ‘이유’가 아닌 ‘설명’이다. 코드의 특정 컴포넌트(module, class, method, function)에 대한 문서화이다. 가능한 많은 docstring을 추가하는 것이 권장된다. Sphinx(스핑크스)를 실행하여 autodoc 익스텐션을 사용하면 자동으로 문서를 만들 수 있다. Example \u003e\u003e\u003e def my_function(): ... \"\"\" ... 1. 이 함수가 하는 일은 무엇인가요? ... ... 2. 이 함수는 무엇을 입력받나요? ... ... 3. 그래서 최종적으로 이 함수는 무엇을 반환하나요? ... \"\"\" ... pass ... \u003e\u003e\u003e my_function.__doc__ '1. 이 함수가 하는 일은 무엇인가요?\\n \\n 2. 이 함수는 무엇을 입력받나요?\\n \\n 3. 그래서 최종적으로 이 함수는 무엇을 반환하나요?\\n' \"\"\"{docstring}\"\"\" : 리터럴 문자열로 특정 컴포넌트에 대한 문서화를 작성 __doc__ : 해당 속성을 통해 docstring에 접근 가능 # dict.update에 대한 docstring 예제 \u003e\u003e\u003e dict.update.__doc__ 'D.update([E, ]**F) -\u003e None. Update D from dict/iterable E and F.\\n If E is present and has a .keys() method, then does: for k in E: D[k] = E[k]\\n If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v\\n In either case, this is followed by: for k in F: D[k] = F[k]' ","date":"2021-03-06","objectID":"/docstring%EA%B3%BC_annotation/:1:0","tags":["Python"],"title":"[Python]Docstring과Annotation","uri":"/docstring%EA%B3%BC_annotation/"},{"categories":null,"content":"Annotation Python의 경우 동적으로 타입을 결정하기 때문에 함수나 메서드를 거치면서 변수나 객체의 값이 무엇인지 알기가 어려운 경우가 많으므로 어노테이션을 통해 이러한 정보를 명시해준다면 다른 개발자가 코드를 쉽게 이해하는데 도움이 된다. Java에도 Annotation이 존재한다. 그러나 Python에서의 Annotation은 단순히 타입에 대한 힌트를 주는 역할만을 하게된다. (Java의 Annotation은 Python의 Decorator가 비슷한 역할을 한다고 볼 수 있다.) Annotation에 대해 간단히 정리해보면 다음과 같다. 변수의 예상 타입을 지정하여 힌트를 줄 수 있다. (타입 뿐만 아니라 어떤 형태의 메타데이터라도 지정할 수 있다.) annotation정보를 사용하여 문서 생성, 유효성 검증, 타입 체크를 할 수 있다. Example \u003e\u003e\u003e class Point: ... def __init__(self, lat, long): ... self.lat = lat ... self.long = long ... \u003e\u003e\u003e def locate(latitude: float, longitude: float) -\u003e Point: ... \"\"\"맴에서 좌표에 해당하는 객체를 검색\"\"\" ... return Point(latitude, longitude) ... \u003e\u003e\u003e locate.__annotations__ {'latitude': \u003cclass 'float'\u003e, 'longitude': \u003cclass 'float'\u003e, 'return': \u003cclass '__main__.Point'\u003e} # 변수에도 지정 가능 (Python 3.6이상) \u003e\u003e\u003e class Point: ... lat: float ... long: float ... \u003e\u003e\u003e Point.__annotations__ {'lat': \u003cclass 'float'\u003e, 'long': \u003cclass 'float'\u003e} # 타입이 아닌 문자열도 가능 \u003e\u003e\u003e def aa() -\u003e \"리턴\": ... pass ... \u003e\u003e\u003e aa.__annotations__ {'return': '리턴'} : : 함수의 파라미터 및 변수 뒤에 콜론을 이용하여 annotation을 달 수 있다. -\u003e : 함수의 반환값에 대한 annotation을 달 수 있다. __annotations__ : 해당 속성을 통해 annotation에 접근 가능 ","date":"2021-03-06","objectID":"/docstring%EA%B3%BC_annotation/:2:0","tags":["Python"],"title":"[Python]Docstring과Annotation","uri":"/docstring%EA%B3%BC_annotation/"},{"categories":null,"content":"Annotation은 Docstring을 대체? Docstring에 포함된 정보의 일부는 어노테이션으로 이동시킬 수 있는 것은 사실이지만, docstring을 통해 보다 나은 문서화를 위한 여지를 남겨두어야 한다. 동적 데이터 타입과 중첩 데이터 타입의 경우 예상 데이터의 예제를 제공하여 어떤 형태의 데이터를 다루는지 제공하는 것이 좋다는 것이다. def data_from_response(response: dict) -\u003e dict: if response[\"status\"] != 200: raise ValueError return {'data': response[\"payload\"]} 예를들어 위와 같이 데이터의 유효성을 검사하고 dict값을 반환하는 함수를 보면 response객체의 올바른 인스턴스의 형태는 알 수가 없다. 따라서 아래와 같이 이러한 함수에 docstring을 통해 보다 나은 설명을 추가할 수가 있다. def data_from_response(response: dict) -\u003e dict: \"\"\"response에 문제가 없다면 response의 payload를 반환 - response의 예:: { \"status\": 200, # \u003cint\u003e \"payload\": { ... } # 반환하려는 데이터 } - 반환 dict 값의 예:: {\"data\": { ... } } - 발생 가능한 예외: - HTTP status가 200이 아닌 경우 ValueError 발생 \"\"\" if response[\"status\"] != 200: raise ValueError return {'data': response[\"payload\"]} 또한, docstring은 단위 테스테에서도 유용한 정보로 사용될 수 있다. 예를들어, 테스트용 입력 값을 생성할 수도 있고 테스트의 성공 실패를 판단하는 것이다. 간단히 정리를 해보자면, Annotation은 Docstring을 부분적으로 대체를 할 수는 있겠지만, Annotation과 Docstring을 적절히 사용하여 코드의 가독성을 높이고 코드에 대한 문서화를 더욱 보기 좋게 다듬는 것이 중요하다고 할 수 있겠다. ","date":"2021-03-06","objectID":"/docstring%EA%B3%BC_annotation/:3:0","tags":["Python"],"title":"[Python]Docstring과Annotation","uri":"/docstring%EA%B3%BC_annotation/"},{"categories":null,"content":"It’s Test post! ","date":"2021-03-01","objectID":"/test_post/:0:0","tags":null,"title":"Test_post","uri":"/test_post/"}]