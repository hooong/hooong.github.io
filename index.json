[{"categories":null,"content":"macOS의 Docker Container에서 host로 접근하는 방법에 대한 정리","date":"2021-06-23","objectID":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/","tags":["Docker"],"title":"Docker Container 내부에서 Host로 접근하는 방법(feat.macOS)","uri":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"개요 SSH Tunneling을 통해 특정 애플리케이션에 접근해야하는 경우가 있을 수 있다. 예를들어, VPC 내부에서만 접근할 수 있는 RDS가 있다고 한다면 호스트에서 바로 RDS로 접근은 불가능하다. RDS에 접근하는 방법으로는 VPC 내부에 있는 EC2(외부에서 접속이 가능한)를 통해서 접근하는 방법이 있다. 이를 SSH Tunneling으로 특정 포트를 포워딩 시켜둔다면 호스트에서는 localhost:{특정 포트}를 사용해 RDS를 접근할 수 있게 된다. 위의 예시 상황에서 RDS에 접근해야하는 곳이 로컬(macOS)가 아닌 로컬에서 실행중인 도커 컨테이너이라고 가정해보자. 만약 network의 세팅값을 특별히 지정하지 않았다면 도커 컨네이너에서 localhost:{특정 포트}를 사용해 RDS를 접근할 수 없을 것이다. 필자는 이러한 상황에 부딛혀 도커 컨테이너에서 로컬(macOS) 호스트로 접근하는 방법에 대해 찾아보게 되었으며 그에 대한 내용을 정리해보고자 한다. ","date":"2021-06-23","objectID":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/:1:0","tags":["Docker"],"title":"Docker Container 내부에서 Host로 접근하는 방법(feat.macOS)","uri":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"두 가지 방법에 대하여.. ","date":"2021-06-23","objectID":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/:2:0","tags":["Docker"],"title":"Docker Container 내부에서 Host로 접근하는 방법(feat.macOS)","uri":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"1. host 네트워크 드라이버 사용 docker는 여러가지의 network 방식을 제공하는데 bridge와 host에 대해 간단히 정리해보면 다음과 같다. bridge network docker0이라는 bridge(172.17.0.1)가 생성되고 컨테이너들이 이 docker0 으로 연결이 되고 이를 통해 외부 또는 내부 컨테이너간의 접근이 가능하다. Host 네트워크와 별개의 독립적인 네트워크를 구성할 수 있다. host network 컨테이너들이 독립적인 네트워크 영역을 갖지 않고 host(macOS)의 네트워크를 같이 사용한다. --net=host 옵션으로 지정할 수 있다. 위에서 두 가지 네트워크 방식을 살펴보았는데 ‘개요’에서 해결하고자 한 문제는 host 네트워크 방식을 사용한다면 localhost:{특정 포트} 를 통해 접속이 가능하게 된다. 하지만 도커 컨테이너 네트워크 영역을 가질 수 없다는 단점이 있다. 또!! 큰 단점이 하나가 더 있다. 바로 이 Host 네트워크 모드는 mac에서는 동작하지 않는다는 것이다. 결론적으로 macOS에서 컨테이너 내부에서 로컬(macOS) 호스트로 접근하기 위해서는 2번 방법을 사용해야한다. ","date":"2021-06-23","objectID":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/:2:1","tags":["Docker"],"title":"Docker Container 내부에서 Host로 접근하는 방법(feat.macOS)","uri":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"2. host.docker.internal 도메인 사용 Docker는 자체적으로 host.docker.internal라는 도메인 네임을 가상으로 제공해준다. 이 도메인 네임을 이용하면 로컬(macOS) 호스트 영역으로 접근을 할 수 있다. 이를 사용한 예를 간단히 보이면 아래와 같다. 로컬 호스트에서 SSH Tunneling을 위해 20000번 포트로 포트포워딩을 해둔 상태라면 도커 컨테이너에서 host.docker.internal:20000 을 통해 RDS로 접속이 가능해진다. ","date":"2021-06-23","objectID":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/:2:2","tags":["Docker"],"title":"Docker Container 내부에서 Host로 접근하는 방법(feat.macOS)","uri":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"결론 이번 글에서는 macOS의 도커 컨테이너 내부에서 로컬(macOS) 호스트로 접근하는 방법에 대하여 알아본 내용을 정리해보았다. 리눅스 머신을 사용한다면 host 네트워크 방식을 사용할 수 있겠지만 macOS에서는 이 host 네트워크 방식이 동작하지 않는다는 점이 있고 독립적인 네트워크를 사용할 수 없다는 단점을 가지고 있었다. 따라서 개요에서와 같은 문제에 부딛혔던 필자는 도커가 제공하는 host.docker.internal이라는 도메인 네임을 이용하므로써 의외로 간단하게 문제를 해결할 수 있었다. 이와 같은 경우가 빈번하지는 않을 것 같지만 해당 내용을 알고 있다면 필요한 상황에서는 꽤 유용하게 사용될 수 있을 것 같다. ","date":"2021-06-23","objectID":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/:3:0","tags":["Docker"],"title":"Docker Container 내부에서 Host로 접근하는 방법(feat.macOS)","uri":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"참고 https://seorenn.tistory.com/20 https://bluese05.tistory.com/38 https://docs.mirantis.com/containers/v3.1/dockeree-ref-arch/networking/scalable-container-networks.html ","date":"2021-06-23","objectID":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/:4:0","tags":["Docker"],"title":"Docker Container 내부에서 Host로 접근하는 방법(feat.macOS)","uri":"/docker_container%EC%97%90%EC%84%9Chost%EB%A1%9C%EC%A0%91%EA%B7%BC%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"입력된 순서를 보장하는 딕셔너리에 대한 정리","date":"2021-05-12","objectID":"/python_dictionary_order/","tags":["Python"],"title":"Python 3.6부터는 Dict가 순서를 기억한다.","uri":"/python_dictionary_order/"},{"categories":null,"content":"입력된 순서를 보장하는 딕셔너리에 대한 정리 딕셔너리에 구현되어 있는 함수들 중 pop()과 popitem()이 있는 것을 보고 “딕셔너리에는 순서가 없는 것으로 알고있었는데 어떻게 큐에서나 사용되는 pop()이 구현될 수 있지?“라는 의문으로 찾아보게 되었던 결과를 글로 옮겨 적어보게 되었습니다. ","date":"2021-05-12","objectID":"/python_dictionary_order/:0:0","tags":["Python"],"title":"Python 3.6부터는 Dict가 순서를 기억한다.","uri":"/python_dictionary_order/"},{"categories":null,"content":"Dictionary란? 이름 - 홍길동, 성별 - 남 과 같이 대응 관계를 나타내는 자료형을 연관 배열 또는 해시라고 하는데 Python에서는 이러한 자료형을 딕셔너리라고 합니다. 딕셔너리는 key: value 쌍의 형식으로 저장되는 자료형이며 특정 key는 해시가 가능한 값으로 해시된 key값을 이용해 value와 매핑을 하게 됩니다. 즉, key로 리스트, 딕셔너리와 같이 mutable한 객체는 사용할 수 없습니다. # dict의 예시 people = {'name': '홍길동', 'age': '22'} key를 해시하여 value에 매핑하는 구조이기 때문에 리스트나 튜플처럼 순차적으로 값에 접근하지 않고 key를 통해 바로 value에 접근을 할 수 있습니다. 이 때문에 Python 3.5 까지는 딕셔너리는 순서를 가지고 있지 않았습니다. ","date":"2021-05-12","objectID":"/python_dictionary_order/:1:0","tags":["Python"],"title":"Python 3.6부터는 Dict가 순서를 기억한다.","uri":"/python_dictionary_order/"},{"categories":null,"content":"OrderedDict란? OrderedDict는 일반적인 딕셔너리(Python 3.6이전)와는 다르게 입력된 순서를 저장하여 순서를 보장해주는 Python이 제공하는 자료형입니다. # 입력된 순서가 보장되는 OrderedDict \u003e\u003e\u003e od = OrderedDict() \u003e\u003e\u003e od['a'] = 1 \u003e\u003e\u003e od['b'] = 2 \u003e\u003e\u003e od['c'] = 3 \u003e\u003e\u003e od OrderedDict([('a', 1), ('b', 2), ('c', 3)]) # Python 3.5 이전에서의 dict는 입력된 순서가 보장되지 않음. \u003e\u003e\u003e d = {} \u003e\u003e\u003e d['a'] = 1 \u003e\u003e\u003e d['b'] = 2 \u003e\u003e\u003e d['c'] = 3 \u003e\u003e\u003e d {'b': 2, 'a': 1, 'c': 3} # Python 3.6 이후에서의 dict는 입력된 순서 보장 \u003e\u003e\u003e d_ = {} \u003e\u003e\u003e d_['a'] = 1 \u003e\u003e\u003e d_['b'] = 2 \u003e\u003e\u003e d_['c'] = 3 \u003e\u003e\u003e d_ {'a': 1, 'b': 2, 'c': 3} 그러나 Python 3.6이후부터는 기존 딕셔너리도 입력된 순서를 가지게 되어 OrderedDict와 크게 차이점이 없다고 생각을 할 수 있습니다. 하지만 동등성을 확인할 때에 OrderedDict는 순서까지도 동등한지를 확인하게 되어 더 엄격하게 동등성을 검증합니다. # 입력 순서가 다른 dict의 비교 \u003e\u003e\u003e dict_a {'a': 'apple', 'b': 'banana', 'p': 'pineapple'} \u003e\u003e\u003e dict_b {'b': 'banana', 'a': 'apple', 'p': 'pineapple'} \u003e\u003e\u003e dict_a == dict_b True # 입력 순서가 다른 OrderedDict의 비교 \u003e\u003e\u003e ordered_a OrderedDict([('a', 'apple'), ('b', 'banana'), ('p', 'pineapple')]) \u003e\u003e\u003e ordered_b OrderedDict([('b', 'banana'), ('a', 'apple'), ('p', 'pineapple')]) \u003e\u003e\u003e ordered_a == ordered_b False 따라서 데이터의 순서가 아주 중요한 상황이나 하위 호환성을 고려해야 할때에는 OrderedDict를 사용하여 순서를 보장하는 것도 고려해야 합니다. ","date":"2021-05-12","objectID":"/python_dictionary_order/:2:0","tags":["Python"],"title":"Python 3.6부터는 Dict가 순서를 기억한다.","uri":"/python_dictionary_order/"},{"categories":null,"content":"Python 3.6 이후 Dict에 순서가 생긴 이유 Python에서 딕셔너리를 구현함에 있어 USABLE_FRACTION을 계산하게 되는데 성능상의 문제로 2/3 * dk_size를 넘지못하는데 Python 3.5 이하 버전에서 딕셔너리를 구현하기 위해 PyDictKeyEntry 타입의 희소배열(빈 공간도 여전히 PyDictKeyEntry만큼의 크기를 가짐.)을 사용하고 이 배열의 크기를 dk_size로 저장하게 되는데, 이 때문에 메모리의 사용량이 컸는데, 이를 Python 3.6에서는 3.5에서와 다르게 두 개의 배열을 사용하여 메모리의 사용량을 줄일 수 있게 됩니다. 참고 : Python 3.6에서부터 순서가 생기는 구조로 변경이 된 것 같은데 Python의 레퍼런스 문서에서는 Python 3.7부터 지원한다고 써있는거 보니 3.7에서부터 공식으로 지원을 하는 것 같습니다. ","date":"2021-05-12","objectID":"/python_dictionary_order/:3:0","tags":["Python"],"title":"Python 3.6부터는 Dict가 순서를 기억한다.","uri":"/python_dictionary_order/"},{"categories":null,"content":"배열의 개수가 늘었는데 메모리의 사용량이 줄었다? 위에서 두 개의 배열을 사용하여 메모리를 줄였다고 하는데 배열이 하나에서 두 개로 늘었는데 줄었다고하면 의문을 가질수도 있습니다. # Python 3.5 d = {'timmy': 'red', 'barry': 'green', 'guido': 'blue'} entries = [['--', '--', '--'], [-8522787127447073495, 'barry', 'green'], ['--', '--', '--'], ['--', '--', '--'], ['--', '--', '--'], [-9092791511155847987, 'timmy', 'red'], ['--', '--', '--'], [-6480567542315338377, 'guido', 'blue']] # Python 3.6 indices = [None, 1, None, None, None, 0, None, 2] entries = [[-9092791511155847987, 'timmy', 'red'], [-8522787127447073495, 'barry', 'green'], [-6480567542315338377, 'guido', 'blue']] 하지만 위의 두 버전에서 각기 다른 구현된 딕셔너리를 살펴보면 이해를 할 수 있습니다. 앞서 설명하였듯이 Python 3.5에서는 entries라는 빈 공간도 PyDictKeyEntry라는 타입으로 채워진 하나의 배열을 사용해 key를 해시하여 얻은 값을 인덱스로 사용하여 저장하였다면, Python 3.6에서는 key와 매핑될 객체를 추가해나가는 entries와 key를 해시하여 얻은 값에 해당하는 위치에 담기는 순서를 저장하는 indices, 총 2개의 배열을 사용하면서 indices는 int 타입의 희소배열을 사용하게 되고 PyDictKeyEntry는 딕셔너리에 담긴 객체의 개수만큼만 크기를 차지하게 되어 메모리를 Python 3.5에서보다 절약이 될 수 있다고 합니다. 또, 이 글을 쓰게 된 이유인 순서를 저장하는 이유가 바로 indices에서 나오게 됩니다. ","date":"2021-05-12","objectID":"/python_dictionary_order/:4:0","tags":["Python"],"title":"Python 3.6부터는 Dict가 순서를 기억한다.","uri":"/python_dictionary_order/"},{"categories":null,"content":"결론 이렇게 Dict, OrderedDict에 대해서 간단히 알아보고 Python 3.5와 3.6에서 딕셔너리의 구현되어 있는 구조를 알아보면서 딕셔너리에 입력 순서가 저장되는 이유에 대해서 알아보았습니다. Python 3.6이후부터 딕셔너리에 순서가 생기기는 했지만, OrderedDict 부분에서 살펴본대로 동등성을 비교하는 부분이 다르고 하위호환을 고려한다면 용도에 맞게 사용하는 것이 좋을 것 같습니다. 참고 사이트 https://docs.python.org/ko/3/library/stdtypes.html#dict https://docs.python.org/3/library/collections.html#collections.OrderedDict https://stackoverflow.com/questions/39980323/are-dictionaries-ordered-in-python-3-6/39980744#39980744 ","date":"2021-05-12","objectID":"/python_dictionary_order/:5:0","tags":["Python"],"title":"Python 3.6부터는 Dict가 순서를 기억한다.","uri":"/python_dictionary_order/"},{"categories":null,"content":"Git의 switch와 restore","date":"2021-04-14","objectID":"/git_switchrestore/","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"Git의 switch와 restore에 대하여… ","date":"2021-04-14","objectID":"/git_switchrestore/:0:0","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"개요 Git 2.23.0 버전 이하에서 checkout 명령어 아래 두 가지의 기능을 동시에 가진다. branch를 전환 working tree의 파일을 복원 이처럼 하나의 명령어가 다른 두 가지 이상의 기능을 동시에 가지게 되면 명시적이지 않을 수 있다. 따라서 Git은 2.23.0버전에서 이 두 가지의 기능을 별도의 명령어로 나누어서 좀 더 명령어를 명시적으로 사용할 수 있게끔 만들었다. * Two new commands \"git switch\" and \"git restore\" are introduced to split \"checking out a branch to work on advancing its history\" and \"checking out paths out of the index and/or a tree-ish to work on advancing the current history\" out of the single \"git checkout\" command. Git v2.23.0 Release Notes 참고로 현재 *Git(2.24.3)*버전 기준으로 $ git --help 로 지원하는 명령어를 살펴보면 checkout 을 찾아볼 수 없다. start a working area (see also: git help tutorial) clone Clone a repository into a new directory init Create an empty Git repository or reinitialize an existing one work on the current change (see also: git help everyday) add Add file contents to the index mv Move or rename a file, a directory, or a symlink restore Restore working tree files rm Remove files from the working tree and from the index examine the history and state (see also: git help revisions) bisect Use binary search to find the commit that introduced a bug diff Show changes between commits, commit and working tree, etc grep Print lines matching a pattern log Show commit logs show Show various types of objects status Show the working tree status grow, mark and tweak your common history branch List, create, or delete branches commit Record changes to the repository merge Join two or more development histories together rebase Reapply commits on top of another base tip reset Reset current HEAD to the specified state switch Switch branches tag Create, list, delete or verify a tag object signed with GPG collaborate (see also: git help workflows) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects ","date":"2021-04-14","objectID":"/git_switchrestore/:1:0","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"switch switch 명령어는 기본적으로 기존에 branch를 이동할 때 사용하던 git checkout \u003cbranch\u003e 와 동일한 기능을 수행한다. ","date":"2021-04-14","objectID":"/git_switchrestore/:2:0","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"SYNOPSIS $ git switch [\u003coption\u003e] [--no-guess] \u003cbranch\u003e $ git switch [\u003coption\u003e] --detach [\u003cstart-point\u003e] $ git switch [\u003coption\u003e] (-c|-C) \u003cnew-brach\u003e [\u003cstart-point\u003e] $ git switch [\u003coption\u003e] --orphan \u003cnew-branch\u003e ","date":"2021-04-14","objectID":"/git_switchrestore/:2:1","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"기본 사용 예시 # issue1이라는 branch를 생성하고 전환 $ git switch -c issue1 # master branch로 전환 $ git switch master # HEAD 이전 커밋의 상태로 이동 $ git switch --detach HEAD~ # 현재 master branch라면 master branch상태에서 issue1 branch가 새로 생성되고 전환 $ git switch switch -C issue1 ","date":"2021-04-14","objectID":"/git_switchrestore/:2:2","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"옵션 설명 \u003cstart-point\u003e 특정 위치에서 branch를 따낸다. default로는 HEAD 이다. -c | --create \u003cnew-branch\u003e \u003cstart-point\u003e 의 위치에서 새로운 branch를 생성하고 전환한다. -C | --force-create \u003cnew-branch\u003e \u003cnew-branch\u003e 가 이미 존재한다면 reset된 상태의 branch를 생성하고 전환한다. --detach 특정 커밋으로 상태를 전환한다. (기존 커밋은 남아있는 상태) -m | --merge Three-way merge를 진행한 뒤 branch를 만들고 전환한다. --orphan 새로운 orphan branch를 생성한 뒤 전환한다. -t | --track -c 옵션과 함께 사용할 때, upstream으로 지정할 원격 저장소의 브랜치를 지정할 수 있다. -c가 없다면 원격 branch에서 새로운 branch를 따서 생성하고 전환한다. --no-track로 지정할 경우에는 upstream을 구성하지 않는다. --guess, --no-guess branch를 생성할 때 원격 저장소에 동일한 이름이 있다면 자동으로 upstream으로 지정하여 매칭한다. --guess가 default이고 --no-guess는 자동으로 매칭이 되지 않게끔 설정한다. 이외의 더 많은 옵션은 git-scm-switch에서 살펴볼 수 있다. ","date":"2021-04-14","objectID":"/git_switchrestore/:2:3","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"restore restore 명령어는 특정 working tree의 파일로 돌리는 기능을 수행한다. ","date":"2021-04-14","objectID":"/git_switchrestore/:3:0","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"SYNOPSIS $ git restore [\u003coption\u003e] [--source=\u003ctree\u003e] [--staged] [--worktree] [--] \u003cpathspec\u003e... $ git restore [\u003coption\u003e] [--source=\u003ctree\u003e] [--staged] [--worktree] --pathspec-from-file=\u003cfile\u003e [--pathspec-file-nul] $ git restore (-p|--patch) [\u003coption\u003e] [--source=\u003ctree\u003e] [--staged] [--worktree] [--] [\u003cpathspec\u003e...] ","date":"2021-04-14","objectID":"/git_switchrestore/:3:1","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"기본 사용 예시 # 현재 디렉터리('.')를 HEAD의 working tree로 복원 $ git restore . # 현재 디렉터리('.')를 특정 커밋('943453b')의 working tree로 복원 $ git restore -s 943453b . # 현재 디렉터리('.')를 특정 branch(issue1)의 working tree로 복원 $ git restore -s issue1 . # 현재 디렉터리('.')를 HEAD~의 index를 복원 $ git restore -s HEAD~ -S . # 현재 디렉터리('.')를 특정 위치의 index와 working tree 모두 복원 $ git restore -s HEAD~ -SW . # 'test.txt'을 unstageing 상태로 복원 $ git restore --staged test.txt ","date":"2021-04-14","objectID":"/git_switchrestore/:3:2","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"옵션 설명 -s \u003ctree\u003e | --source=\u003ctree\u003e 특정 \u003ctree\u003e(commit, branch) 위치를 지정한다. -S | --staged 특정 위치의 index만을 복원한다. -s 옵션이 지정되지 않으면 기본으로 HEAD로 지정된다. -W | --worktree 특정 위치의 working tree를 복원한다. -S 와 -W를 모두 지정하면 index와 working tree 모두 복원한다. -S와 동일하게 -s옵션이 지정되지 않으면 기본으로 HEAD로 지정된다. -p | --patch 대화 모드로 명령어를 실행한다. 이외의 더 많은 옵션은 git-scm-restore에서 살펴볼 수 있다. 마무리하며… Git의 --help에서도 checkout 명령어를 삭제한 것을 보니 switch와 restore의 사용을 권장하고 있다는 것을 알 수 있었고, 본인도 기존에 checkout 명령어를 사용하였기에 switch와 restore를 최대한 의식적으로 사용해보고 있는데 확실히 기능이 분리되어 명시적으로 사용할 수 있어 좋다고 느껴졌다. 이 글을 읽으시는 여러분들도 익숙한 checkout을 대신하여 switch와 restore를 사용해보는 것을 추천합니다! ","date":"2021-04-14","objectID":"/git_switchrestore/:3:3","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"Python의 Property","date":"2021-04-05","objectID":"/python_property/","tags":["Python"],"title":"[Python]property","uri":"/python_property/"},{"categories":null,"content":"Python에서 prooperty에 대한 정리 ","date":"2021-04-05","objectID":"/python_property/:0:0","tags":["Python"],"title":"[Python]property","uri":"/python_property/"},{"categories":null,"content":"Property 이 글은 파이썬 클린코드 책의 내용을 정리한 글입니다. 프로퍼티는 객체의 어떤 속성에 대한 접근을 제어하려는 경우 사용한다. 이렇게 하는게 또한 파이썬스러운 코드라고 한다. 프로퍼티는 자바에서의 접근메서드인 getter와 setter를 만드는 것과 같은 용도라고 할 수 있다. def is_valid_email(potentially_valid_email: str): return re.match(EMAIL_FORMAT, potentially_valid_email) is not None class User: def __init__(self, username): self.username = username self._email = None @property def email(self): return self._email @email.setter def email(self, new_email): if not is_valid_email(new_email): raise ValueError(f'유요한 이메일이 아니므로 {new_email} 값을 사용할 수 없음') self._email = new_email @email.deleter def email(self): self._email = None # 사용 예시 \u003e hong = User('hong') \u003e hong.email = 'hong@test.kr' \u003e hong.email 'hong@test.kr' \u003e del hong.email \u003e hong.__dict__ {'username': 'hong', '_email': None} @property가 붙은 메서드는 private 속성인 email 값을 반환한다. @email.setter가 붙은 메서드는 email값을 검증한 뒤 업데이트한다. @email.deleter가 붙은 메서드는 email 속성을 None로 초기화한다. 프로퍼티를 사용하면 명령-쿼리 분리 원칙(command and query separation)을 따르기 위한 좋은 방법이다. 명령-쿼리 분리 원칙이란? 객체의 메서드가 무언가의 상태를 변경하는 커맨드이거나 무언가의 값을 반환하는 쿼리이거나 둘 중에 하나만 수행해야지 둘 다 동시에 수행하면 안된다는 것 즉, 프로퍼티를 명령-쿼리로 나누어보면 @property 데코레이터는 무언가에 응답하기 위한 쿼리이고, @\u003cproperty_name\u003e.setter, @\u003cproperty_name\u003e.deleter데코레이터는 무언가를 하기 위한 커맨드이다. 또한, 책에서 덧붙이는 팁은 메서드는 한 가지만 수행해야 한다. 작업을 처리한 다음 상태를 확인하려면 메서드를 분리해야 한다. 이다. 예를들어 if self.set_email(\"a@j.com\")처럼 코드를 사용하게 되면 이메일을 설정하려는 건지, 이미 이메일이 해당 값으로 설정되어 있는지 확인하려는지, 아니면 동시에 이메일 값을 설정하고 상태가 유효한지 체크하는 것인지를 구분하기 어렵기때문이다. ","date":"2021-04-05","objectID":"/python_property/:1:0","tags":["Python"],"title":"[Python]property","uri":"/python_property/"},{"categories":null,"content":"추가적인 프로퍼티 사용법 위의 프로퍼티는 데코레이터를 사용한 방법이고 아래는 property class를 직접적으로 사용한 예제이다. class property(fget=None, fset=None, fdel=None, doc=None) # Return a property attribute class C: def __init__(self): self._x = None def getx(self): return self._x def setx(self7777777777, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, \"I'm the 'x' property.\") # property 객체 반환 \u003e C.x \u003cproperty object at 0x109119cc0\u003e # property doc \u003e C.x.__doc__ \"I'm the 'x' property.\" \u003e a = C() # setx \u003e a.x = 'haha' # getx \u003e a.x 'haha' # delx \u003e del a.x ","date":"2021-04-05","objectID":"/python_property/:2:0","tags":["Python"],"title":"[Python]property","uri":"/python_property/"},{"categories":null,"content":"Python의 _, __에 대한 설명","date":"2021-04-05","objectID":"/python_private/","tags":["Python"],"title":"[Python]Private (_, __)","uri":"/python_private/"},{"categories":null,"content":"Python에서 Private속성을 다루는 방법과 name mangling에 대한 정리 ","date":"2021-04-05","objectID":"/python_private/:0:0","tags":["Python"],"title":"[Python]Private (_, __)","uri":"/python_private/"},{"categories":null,"content":"_ python은 java에서의 private처럼 객체 내부에서만 접근할 수 있는 «비공개» 인스턴스 변수는 존재하지 않는다. 그러나 변수명 앞에 _를 붙이는 규약을 통해 공개적이지 않은 부분으로 취급하는 규약이 있다. 이는 규약일 뿐, 얼마든지 해당 변수에 접근과 변경이 가능하다. class Person: def __init__(self, name, age, weight): self.name = name self.age = age self._weight = weight \u003e\u003e\u003e harry = Person('harry', 25, 70) \u003e\u003e\u003e harry.name 'harry' # _weight 접근 가능 \u003e\u003e\u003e harry._weight 70 # _weihgt 변경 가능 \u003e\u003e\u003e harry._weight = 80 \u003e\u003e\u003e harry._weight 80 ","date":"2021-04-05","objectID":"/python_private/:1:0","tags":["Python"],"title":"[Python]Private (_, __)","uri":"/python_private/"},{"categories":null,"content":"__ 그런데 변수명 앞에 __를 붙이고 접근을 하면 AttributeError가 발생하는 것을 확인할 수 있다. class Person: self.name = name self.age = age self.__weight = weight \u003e\u003e\u003e poter = Person('poter', 17, 60) \u003e\u003e\u003e poter.__weight Traceback (most recent call last): File \"\u003cinput\u003e\", line 1, in \u003cmodule\u003e AttributeError: 'Person' object has no attribute '__weight' __를 붙여서 접근을 못하게끔하여 private한 변수로 만드는 것으로 생각할 수도 있다. 그러나 AttributeError는 해당 필드(__weight)가 존재하지 않는다는 에러이다. Python에서 이는 이름 뒤섞기(name mangling)이라는 것으로 _\u003cclass-name\u003e__\u003cattribute-name\u003e이라는 속성을 만든다. 따라서 위의 예제에서 __weight에 접근하기 위해서는 아래와 같이 접근할 수 있다. \u003e\u003e\u003e poter._Person__weight 60 # poter가 가진 인스턴스 변수 확인 \u003e\u003e\u003e poter.__dict__ {'name': 'poter', 'age': 17, '_Person__weight': 65} # 물론 변경도 가능하다. \u003e\u003e\u003e poter._Person__weight = 65 \u003e\u003e\u003e poter._Person__weight?ㅇ 65 이러한 기능은 서브 클래스에서 정의된 이름들과의 충돌을 피하고자 존재한다고 한다. 따라서 클래스 내부의 메서드 호출을 방해하지 않고 서브 클래스들이 메서드를 재정의할 수 있도록 하는데 도움을 준다고 한다. Python Doc ","date":"2021-04-05","objectID":"/python_private/:2:0","tags":["Python"],"title":"[Python]Private (_, __)","uri":"/python_private/"},{"categories":null,"content":"하나의 맥북에서 두 개의 깃헙 계정을 사용하는 방법에 대한 정리","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"하나의 맥북에서 두 개의 깃헙 계정을 사용하는 방법에 대한 정리 하나의 맥북에서 다른 두 개의 깃헙 계정을 사용해 푸시를 하고 싶은 상황이 생겨 알아보니 ssh-key를 사용하면 가능하였다. ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:0:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"1. ssh-key 생성하기 $ cd ~/.ssh $ ssh-keygen -t rsa -C \"{github 계정 이메일}\" Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): {key 이름 지정} $ ls -rw------- 1 hongseokjun staff 411B 3 7 00:35 id_rsa_work -rw-r--r-- 1 hongseokjun staff 102B 3 7 00:35 id_rsa_work.pub -rw------- 1 hongseokjun staff 411B 3 7 00:35 id_rsa_persnal -rw-r--r-- 1 hongseokjun staff 102B 3 7 00:35 id_rsa_persnal.pub ~/.ssh 디렉토리로 이동 후 두 번째 명령어를 실행하고 {key 이름 지정} 부분에 원하는 key 이름을 입력해준다. (ex. id_rsa_work) 위의 과정을 필요한 계정만큼 반복한다. (여기서는 두 개를 예로 듦.) 끝이나면 id_rsa_work, id_rsa_work.pub, id_rsa_persnal, id_rsa_persnal.pub라는 이름의 파일들이 생성된 것을 확인한다. ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:1:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"2. ssh-agent에 ssh-key 등록 $ ssh-add -K ~/.ssh/id_rsa_work $ ssh-add -K ~/.ssh/id_rsa_persnal ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:2:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"3. GitHub에 공개키 등록 로컬에서 생성한 공개키를 복사한다. $ pbcopy \u003c ~/.ssh/id_rsa_work.pub github에 ssh-key에 해당하는 계정으로 로그인 github 계정의 settings - SSH and GPG keys 메뉴를 클릭한다. 3. `New SSH key`를 클릭 4. `title`에는 key에 대한 이름을 지정하고 `key`에 1번에서 복사한 내용을 붙여넣어 준다. 5. 필요한 계정만큼 반복해준다. ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:3:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"4. ssh config $ cd ~/.ssh $ vi config # 없다면 생성 # 아래 내용을 입력 Host github.com-work HostName github.com User work IdentityFile ~/.ssh/id_rsa_work Host github.com-persnal HostName github.com User persnal IdentityFile ~/.ssh/id_rsa_persanl Host : 저장소를 구분하는 일종의 key IdentityFile : ssh-key를 지정 ssh 테스트 해보기 $ ssh -T git@github.com-work Hi {GithubID}! You've successfully authenticated, but GitHub does not provide shell access. 아래 문구가 뜬다면 정상이다. ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:4:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"5. 특정 프로젝트의 git config $ vi {프로젝트}/.git/config ... [user] email = {푸시할 계정의 이메일} git의 global config가 설정되어있는 경우, 위와 같은 설정을 해주어야 해당 계정으로 푸시를 할 수 있음. ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:5:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"6. remote 설정 github에서 git ssh로 clone을 받을 수 있다. : git@github.com-work:work/{프로젝트}.git 또는 이미 remote가 지정되어 있는 상태라면 아래 명령어를 통해 ssh로 바꿀 수 있다. $ git remote set-url origin git@{Host}:{User}/{프로젝트}.git ex. git remote set-url origin git@github.com-work:work/{프로젝트}.git 참고 https://docs.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent https://velog.io/@sonypark/GitHubSSH%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4-%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-%EA%B9%83%ED%97%88%EB%B8%8C-%EA%B3%84%EC%A0%95-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-6mk3iesh0u ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:6:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"Python의 Docstring과 Annotation에 대한 정리","date":"2021-03-06","objectID":"/docstring%EA%B3%BC_annotation/","tags":["Python"],"title":"[Python]Docstring과Annotation","uri":"/docstring%EA%B3%BC_annotation/"},{"categories":null,"content":"Python의 Docstring과 Annotation에 대한 정리 훌륭한 코드는 그 자체로 (주석이 없어도) 자명하지만 문서화 또한 잘 되어있어야한다. 문서화라고해서 주석이 주렁주렁 달린 코드를 말하는 것이 아닌 문서화를 통해 데이터 타입이 무엇인지 설명하고 때에따라 예제를 제공하는 것을 목표로 한다. ","date":"2021-03-06","objectID":"/docstring%EA%B3%BC_annotation/:0:0","tags":["Python"],"title":"[Python]Docstring과Annotation","uri":"/docstring%EA%B3%BC_annotation/"},{"categories":null,"content":"Docstring Docstring은 소스코드에 포함된 문서라고 말할 수 있으며, 기본적으로 리터럴 문자열로 구성되며 로직의 일부분을 문서화하기 위해 코드 어딘가에 배치된다. 파이썬의 경우 동적 타이핑을 하기 때문에 함수의 입력과 출력을 문서화하여 사용자가 사용할 때 함수가 어떻게 동작하는지 이해하기 쉽게끔 docstring으로 문서화를 하는 것이 코드의 동작을 이해하는데 큰 도움이 될 수 있다. 따라서 Docstring을 아래와 같이 정리해 볼 수 있다. Docstring은 ‘이유’가 아닌 ‘설명’이다. 코드의 특정 컴포넌트(module, class, method, function)에 대한 문서화이다. 가능한 많은 docstring을 추가하는 것이 권장된다. Sphinx(스핑크스)를 실행하여 autodoc 익스텐션을 사용하면 자동으로 문서를 만들 수 있다. Example \u003e\u003e\u003e def my_function(): ... \"\"\" ... 1. 이 함수가 하는 일은 무엇인가요? ... ... 2. 이 함수는 무엇을 입력받나요? ... ... 3. 그래서 최종적으로 이 함수는 무엇을 반환하나요? ... \"\"\" ... pass ... \u003e\u003e\u003e my_function.__doc__ '1. 이 함수가 하는 일은 무엇인가요?\\n \\n 2. 이 함수는 무엇을 입력받나요?\\n \\n 3. 그래서 최종적으로 이 함수는 무엇을 반환하나요?\\n' \"\"\"{docstring}\"\"\" : 리터럴 문자열로 특정 컴포넌트에 대한 문서화를 작성 __doc__ : 해당 속성을 통해 docstring에 접근 가능 # dict.update에 대한 docstring 예제 \u003e\u003e\u003e dict.update.__doc__ 'D.update([E, ]**F) -\u003e None. Update D from dict/iterable E and F.\\n If E is present and has a .keys() method, then does: for k in E: D[k] = E[k]\\n If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v\\n In either case, this is followed by: for k in F: D[k] = F[k]' ","date":"2021-03-06","objectID":"/docstring%EA%B3%BC_annotation/:1:0","tags":["Python"],"title":"[Python]Docstring과Annotation","uri":"/docstring%EA%B3%BC_annotation/"},{"categories":null,"content":"Annotation Python의 경우 동적으로 타입을 결정하기 때문에 함수나 메서드를 거치면서 변수나 객체의 값이 무엇인지 알기가 어려운 경우가 많으므로 어노테이션을 통해 이러한 정보를 명시해준다면 다른 개발자가 코드를 쉽게 이해하는데 도움이 된다. Java에도 Annotation이 존재한다. 그러나 Python에서의 Annotation은 단순히 타입에 대한 힌트를 주는 역할만을 하게된다. (Java의 Annotation은 Python의 Decorator가 비슷한 역할을 한다고 볼 수 있다.) Annotation에 대해 간단히 정리해보면 다음과 같다. 변수의 예상 타입을 지정하여 힌트를 줄 수 있다. (타입 뿐만 아니라 어떤 형태의 메타데이터라도 지정할 수 있다.) annotation정보를 사용하여 문서 생성, 유효성 검증, 타입 체크를 할 수 있다. Example \u003e\u003e\u003e class Point: ... def __init__(self, lat, long): ... self.lat = lat ... self.long = long ... \u003e\u003e\u003e def locate(latitude: float, longitude: float) -\u003e Point: ... \"\"\"맴에서 좌표에 해당하는 객체를 검색\"\"\" ... return Point(latitude, longitude) ... \u003e\u003e\u003e locate.__annotations__ {'latitude': \u003cclass 'float'\u003e, 'longitude': \u003cclass 'float'\u003e, 'return': \u003cclass '__main__.Point'\u003e} # 변수에도 지정 가능 (Python 3.6이상) \u003e\u003e\u003e class Point: ... lat: float ... long: float ... \u003e\u003e\u003e Point.__annotations__ {'lat': \u003cclass 'float'\u003e, 'long': \u003cclass 'float'\u003e} # 타입이 아닌 문자열도 가능 \u003e\u003e\u003e def aa() -\u003e \"리턴\": ... pass ... \u003e\u003e\u003e aa.__annotations__ {'return': '리턴'} : : 함수의 파라미터 및 변수 뒤에 콜론을 이용하여 annotation을 달 수 있다. -\u003e : 함수의 반환값에 대한 annotation을 달 수 있다. __annotations__ : 해당 속성을 통해 annotation에 접근 가능 ","date":"2021-03-06","objectID":"/docstring%EA%B3%BC_annotation/:2:0","tags":["Python"],"title":"[Python]Docstring과Annotation","uri":"/docstring%EA%B3%BC_annotation/"},{"categories":null,"content":"Annotation은 Docstring을 대체? Docstring에 포함된 정보의 일부는 어노테이션으로 이동시킬 수 있는 것은 사실이지만, docstring을 통해 보다 나은 문서화를 위한 여지를 남겨두어야 한다. 동적 데이터 타입과 중첩 데이터 타입의 경우 예상 데이터의 예제를 제공하여 어떤 형태의 데이터를 다루는지 제공하는 것이 좋다는 것이다. def data_from_response(response: dict) -\u003e dict: if response[\"status\"] != 200: raise ValueError return {'data': response[\"payload\"]} 예를들어 위와 같이 데이터의 유효성을 검사하고 dict값을 반환하는 함수를 보면 response객체의 올바른 인스턴스의 형태는 알 수가 없다. 따라서 아래와 같이 이러한 함수에 docstring을 통해 보다 나은 설명을 추가할 수가 있다. def data_from_response(response: dict) -\u003e dict: \"\"\"response에 문제가 없다면 response의 payload를 반환 - response의 예:: { \"status\": 200, # \u003cint\u003e \"payload\": { ... } # 반환하려는 데이터 } - 반환 dict 값의 예:: {\"data\": { ... } } - 발생 가능한 예외: - HTTP status가 200이 아닌 경우 ValueError 발생 \"\"\" if response[\"status\"] != 200: raise ValueError return {'data': response[\"payload\"]} 또한, docstring은 단위 테스테에서도 유용한 정보로 사용될 수 있다. 예를들어, 테스트용 입력 값을 생성할 수도 있고 테스트의 성공 실패를 판단하는 것이다. 간단히 정리를 해보자면, Annotation은 Docstring을 부분적으로 대체를 할 수는 있겠지만, Annotation과 Docstring을 적절히 사용하여 코드의 가독성을 높이고 코드에 대한 문서화를 더욱 보기 좋게 다듬는 것이 중요하다고 할 수 있겠다. ","date":"2021-03-06","objectID":"/docstring%EA%B3%BC_annotation/:3:0","tags":["Python"],"title":"[Python]Docstring과Annotation","uri":"/docstring%EA%B3%BC_annotation/"}]