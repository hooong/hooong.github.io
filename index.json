[{"categories":null,"content":"Git의 switch와 restore","date":"2021-04-14","objectID":"/git_switchrestore/","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"Git의 switch와 restore에 대하여… ","date":"2021-04-14","objectID":"/git_switchrestore/:0:0","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"개요 Git 2.23.0 버전 이하에서 checkout 명령어 아래 두 가지의 기능을 동시에 가진다. branch를 전환 working tree의 파일을 복원 이처럼 하나의 명령어가 다른 두 가지 이상의 기능을 동시에 가지게 되면 명시적이지 않을 수 있다. 따라서 Git은 2.23.0버전에서 이 두 가지의 기능을 별도의 명령어로 나누어서 좀 더 명령어를 명시적으로 사용할 수 있게끔 만들었다. * Two new commands \"git switch\" and \"git restore\" are introduced to split \"checking out a branch to work on advancing its history\" and \"checking out paths out of the index and/or a tree-ish to work on advancing the current history\" out of the single \"git checkout\" command. Git v2.23.0 Release Notes 참고로 현재 *Git(2.24.3)*버전 기준으로 $ git --help 로 지원하는 명령어를 살펴보면 checkout 을 찾아볼 수 없다. start a working area (see also: git help tutorial) clone Clone a repository into a new directory init Create an empty Git repository or reinitialize an existing one work on the current change (see also: git help everyday) add Add file contents to the index mv Move or rename a file, a directory, or a symlink restore Restore working tree files rm Remove files from the working tree and from the index examine the history and state (see also: git help revisions) bisect Use binary search to find the commit that introduced a bug diff Show changes between commits, commit and working tree, etc grep Print lines matching a pattern log Show commit logs show Show various types of objects status Show the working tree status grow, mark and tweak your common history branch List, create, or delete branches commit Record changes to the repository merge Join two or more development histories together rebase Reapply commits on top of another base tip reset Reset current HEAD to the specified state switch Switch branches tag Create, list, delete or verify a tag object signed with GPG collaborate (see also: git help workflows) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects ","date":"2021-04-14","objectID":"/git_switchrestore/:1:0","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"switch switch 명령어는 기본적으로 기존에 branch를 이동할 때 사용하던 git checkout \u003cbranch\u003e 와 동일한 기능을 수행한다. ","date":"2021-04-14","objectID":"/git_switchrestore/:2:0","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"SYNOPSIS $ git switch [\u003coption\u003e] [--no-guess] \u003cbranch\u003e $ git switch [\u003coption\u003e] --detach [\u003cstart-point\u003e] $ git switch [\u003coption\u003e] (-c|-C) \u003cnew-brach\u003e [\u003cstart-point\u003e] $ git switch [\u003coption\u003e] --orphan \u003cnew-branch\u003e ","date":"2021-04-14","objectID":"/git_switchrestore/:2:1","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"기본 사용 예시 # issue1이라는 branch를 생성하고 전환 $ git switch -c issue1 # master branch로 전환 $ git switch master # HEAD 이전 커밋의 상태로 이동 $ git switch --detach HEAD~ # 현재 master branch라면 master branch상태에서 issue1 branch가 새로 생성되고 전환 $ git switch switch -C issue1 ","date":"2021-04-14","objectID":"/git_switchrestore/:2:2","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"옵션 설명 \u003cstart-point\u003e 특정 위치에서 branch를 따낸다. default로는 HEAD 이다. -c | --create \u003cnew-branch\u003e \u003cstart-point\u003e 의 위치에서 새로운 branch를 생성하고 전환한다. -C | --force-create \u003cnew-branch\u003e \u003cnew-branch\u003e 가 이미 존재한다면 reset된 상태의 branch를 생성하고 전환한다. --detach 특정 커밋으로 상태를 전환한다. (기존 커밋은 남아있는 상태) -m | --merge Three-way merge를 진행한 뒤 branch를 만들고 전환한다. --orphan 새로운 orphan branch를 생성한 뒤 전환한다. -t | --track -c 옵션과 함께 사용할 때, upstream으로 지정할 원격 저장소의 브랜치를 지정할 수 있다. -c가 없다면 원격 branch에서 새로운 branch를 따서 생성하고 전환한다. --no-track로 지정할 경우에는 upstream을 구성하지 않는다. --guess, --no-guess branch를 생성할 때 원격 저장소에 동일한 이름이 있다면 자동으로 upstream으로 지정하여 매칭한다. --guess가 default이고 --no-guess는 자동으로 매칭이 되지 않게끔 설정한다. 이외의 더 많은 옵션은 git-scm-switch에서 살펴볼 수 있다. ","date":"2021-04-14","objectID":"/git_switchrestore/:2:3","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"restore restore 명령어는 특정 working tree의 파일로 돌리는 기능을 수행한다. ","date":"2021-04-14","objectID":"/git_switchrestore/:3:0","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"SYNOPSIS $ git restore [\u003coption\u003e] [--source=\u003ctree\u003e] [--staged] [--worktree] [--] \u003cpathspec\u003e... $ git restore [\u003coption\u003e] [--source=\u003ctree\u003e] [--staged] [--worktree] --pathspec-from-file=\u003cfile\u003e [--pathspec-file-nul] $ git restore (-p|--patch) [\u003coption\u003e] [--source=\u003ctree\u003e] [--staged] [--worktree] [--] [\u003cpathspec\u003e...] ","date":"2021-04-14","objectID":"/git_switchrestore/:3:1","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"기본 사용 예시 # 현재 디렉터리('.')를 HEAD의 working tree로 복원 $ git restore . # 현재 디렉터리('.')를 특정 커밋('943453b')의 working tree로 복원 $ git restore -s 943453b . # 현재 디렉터리('.')를 특정 branch(issue1)의 working tree로 복원 $ git restore -s issue1 . # 현재 디렉터리('.')를 HEAD~의 index를 복원 $ git restore -s HEAD~ -S . # 현재 디렉터리('.')를 특정 위치의 index와 working tree 모두 복원 $ git restore -s HEAD~ -SW . # 'test.txt'을 unstageing 상태로 복원 $ git restore --staged test.txt ","date":"2021-04-14","objectID":"/git_switchrestore/:3:2","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"옵션 설명 -s \u003ctree\u003e | --source=\u003ctree\u003e 특정 \u003ctree\u003e(commit, branch) 위치를 지정한다. -S | --staged 특정 위치의 index만을 복원한다. -s 옵션이 지정되지 않으면 기본으로 HEAD로 지정된다. -W | --worktree 특정 위치의 working tree를 복원한다. -S 와 -W를 모두 지정하면 index와 working tree 모두 복원한다. -S와 동일하게 -s옵션이 지정되지 않으면 기본으로 HEAD로 지정된다. -p | --patch 대화 모드로 명령어를 실행한다. 이외의 더 많은 옵션은 git-scm-restore에서 살펴볼 수 있다. 마무리하며… Git의 --help에서도 checkout 명령어를 삭제한 것을 보니 switch와 restore의 사용을 권장하고 있다는 것을 알 수 있었고, 본인도 기존에 checkout 명령어를 사용하였기에 switch와 restore를 최대한 의식적으로 사용해보고 있는데 확실히 기능이 분리되어 명시적으로 사용할 수 있어 좋다고 느껴졌다. 이 글을 읽으시는 여러분들도 익숙한 checkout을 대신하여 switch와 restore를 사용해보는 것을 추천합니다! ","date":"2021-04-14","objectID":"/git_switchrestore/:3:3","tags":["Git"],"title":"[Git]switch + restore (= checkout?)","uri":"/git_switchrestore/"},{"categories":null,"content":"Python의 Property","date":"2021-04-05","objectID":"/python_property/","tags":["Python"],"title":"[Python]property","uri":"/python_property/"},{"categories":null,"content":"Python에서 prooperty에 대한 정리 ","date":"2021-04-05","objectID":"/python_property/:0:0","tags":["Python"],"title":"[Python]property","uri":"/python_property/"},{"categories":null,"content":"Property 이 글은 파이썬 클린코드 책의 내용을 정리한 글입니다. 프로퍼티는 객체의 어떤 속성에 대한 접근을 제어하려는 경우 사용한다. 이렇게 하는게 또한 파이썬스러운 코드라고 한다. 프로퍼티는 자바에서의 접근메서드인 getter와 setter를 만드는 것과 같은 용도라고 할 수 있다. def is_valid_email(potentially_valid_email: str): return re.match(EMAIL_FORMAT, potentially_valid_email) is not None class User: def __init__(self, username): self.username = username self._email = None @property def email(self): return self._email @email.setter def email(self, new_email): if not is_valid_email(new_email): raise ValueError(f'유요한 이메일이 아니므로 {new_email} 값을 사용할 수 없음') self._email = new_email @email.deleter def email(self): self._email = None # 사용 예시 \u003e hong = User('hong') \u003e hong.email = 'hong@test.kr' \u003e hong.email 'hong@test.kr' \u003e del hong.email \u003e hong.__dict__ {'username': 'hong', '_email': None} @property가 붙은 메서드는 private 속성인 email 값을 반환한다. @email.setter가 붙은 메서드는 email값을 검증한 뒤 업데이트한다. @email.deleter가 붙은 메서드는 email 속성을 None로 초기화한다. 프로퍼티를 사용하면 명령-쿼리 분리 원칙(command and query separation)을 따르기 위한 좋은 방법이다. 명령-쿼리 분리 원칙이란? 객체의 메서드가 무언가의 상태를 변경하는 커맨드이거나 무언가의 값을 반환하는 쿼리이거나 둘 중에 하나만 수행해야지 둘 다 동시에 수행하면 안된다는 것 즉, 프로퍼티를 명령-쿼리로 나누어보면 @property 데코레이터는 무언가에 응답하기 위한 쿼리이고, @\u003cproperty_name\u003e.setter, @\u003cproperty_name\u003e.deleter데코레이터는 무언가를 하기 위한 커맨드이다. 또한, 책에서 덧붙이는 팁은 메서드는 한 가지만 수행해야 한다. 작업을 처리한 다음 상태를 확인하려면 메서드를 분리해야 한다. 이다. 예를들어 if self.set_email(\"a@j.com\")처럼 코드를 사용하게 되면 이메일을 설정하려는 건지, 이미 이메일이 해당 값으로 설정되어 있는지 확인하려는지, 아니면 동시에 이메일 값을 설정하고 상태가 유효한지 체크하는 것인지를 구분하기 어렵기때문이다. ","date":"2021-04-05","objectID":"/python_property/:1:0","tags":["Python"],"title":"[Python]property","uri":"/python_property/"},{"categories":null,"content":"추가적인 프로퍼티 사용법 위의 프로퍼티는 데코레이터를 사용한 방법이고 아래는 property class를 직접적으로 사용한 예제이다. class property(fget=None, fset=None, fdel=None, doc=None) # Return a property attribute class C: def __init__(self): self._x = None def getx(self): return self._x def setx(self7777777777, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, \"I'm the 'x' property.\") # property 객체 반환 \u003e C.x \u003cproperty object at 0x109119cc0\u003e # property doc \u003e C.x.__doc__ \"I'm the 'x' property.\" \u003e a = C() # setx \u003e a.x = 'haha' # getx \u003e a.x 'haha' # delx \u003e del a.x ","date":"2021-04-05","objectID":"/python_property/:2:0","tags":["Python"],"title":"[Python]property","uri":"/python_property/"},{"categories":null,"content":"Python의 _, __에 대한 설명","date":"2021-04-05","objectID":"/python_private/","tags":["Python"],"title":"[Python]Private (_, __)","uri":"/python_private/"},{"categories":null,"content":"Python에서 Private속성을 다루는 방법과 name mangling에 대한 정리 ","date":"2021-04-05","objectID":"/python_private/:0:0","tags":["Python"],"title":"[Python]Private (_, __)","uri":"/python_private/"},{"categories":null,"content":"_ python은 java에서의 private처럼 객체 내부에서만 접근할 수 있는 «비공개» 인스턴스 변수는 존재하지 않는다. 그러나 변수명 앞에 _를 붙이는 규약을 통해 공개적이지 않은 부분으로 취급하는 규약이 있다. 이는 규약일 뿐, 얼마든지 해당 변수에 접근과 변경이 가능하다. class Person: def __init__(self, name, age, weight): self.name = name self.age = age self._weight = weight \u003e\u003e\u003e harry = Person('harry', 25, 70) \u003e\u003e\u003e harry.name 'harry' # _weight 접근 가능 \u003e\u003e\u003e harry._weight 70 # _weihgt 변경 가능 \u003e\u003e\u003e harry._weight = 80 \u003e\u003e\u003e harry._weight 80 ","date":"2021-04-05","objectID":"/python_private/:1:0","tags":["Python"],"title":"[Python]Private (_, __)","uri":"/python_private/"},{"categories":null,"content":"__ 그런데 변수명 앞에 __를 붙이고 접근을 하면 AttributeError가 발생하는 것을 확인할 수 있다. class Person: self.name = name self.age = age self.__weight = weight \u003e\u003e\u003e poter = Person('poter', 17, 60) \u003e\u003e\u003e poter.__weight Traceback (most recent call last): File \"\u003cinput\u003e\", line 1, in \u003cmodule\u003e AttributeError: 'Person' object has no attribute '__weight' __를 붙여서 접근을 못하게끔하여 private한 변수로 만드는 것으로 생각할 수도 있다. 그러나 AttributeError는 해당 필드(__weight)가 존재하지 않는다는 에러이다. Python에서 이는 이름 뒤섞기(name mangling)이라는 것으로 _\u003cclass-name\u003e__\u003cattribute-name\u003e이라는 속성을 만든다. 따라서 위의 예제에서 __weight에 접근하기 위해서는 아래와 같이 접근할 수 있다. \u003e\u003e\u003e poter._Person__weight 60 # poter가 가진 인스턴스 변수 확인 \u003e\u003e\u003e poter.__dict__ {'name': 'poter', 'age': 17, '_Person__weight': 65} # 물론 변경도 가능하다. \u003e\u003e\u003e poter._Person__weight = 65 \u003e\u003e\u003e poter._Person__weight?ㅇ 65 이러한 기능은 서브 클래스에서 정의된 이름들과의 충돌을 피하고자 존재한다고 한다. 따라서 클래스 내부의 메서드 호출을 방해하지 않고 서브 클래스들이 메서드를 재정의할 수 있도록 하는데 도움을 준다고 한다. Python Doc ","date":"2021-04-05","objectID":"/python_private/:2:0","tags":["Python"],"title":"[Python]Private (_, __)","uri":"/python_private/"},{"categories":null,"content":"하나의 맥북에서 두 개의 깃헙 계정을 사용하는 방법에 대한 정리","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"하나의 맥북에서 두 개의 깃헙 계정을 사용하는 방법에 대한 정리 하나의 맥북에서 다른 두 개의 깃헙 계정을 사용해 푸시를 하고 싶은 상황이 생겨 알아보니 ssh-key를 사용하면 가능하였다. ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:0:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"1. ssh-key 생성하기 $ cd ~/.ssh $ ssh-keygen -t rsa -C \"{github 계정 이메일}\" Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): {key 이름 지정} $ ls -rw------- 1 hongseokjun staff 411B 3 7 00:35 id_rsa_work -rw-r--r-- 1 hongseokjun staff 102B 3 7 00:35 id_rsa_work.pub -rw------- 1 hongseokjun staff 411B 3 7 00:35 id_rsa_persnal -rw-r--r-- 1 hongseokjun staff 102B 3 7 00:35 id_rsa_persnal.pub ~/.ssh 디렉토리로 이동 후 두 번째 명령어를 실행하고 {key 이름 지정} 부분에 원하는 key 이름을 입력해준다. (ex. id_rsa_work) 위의 과정을 필요한 계정만큼 반복한다. (여기서는 두 개를 예로 듦.) 끝이나면 id_rsa_work, id_rsa_work.pub, id_rsa_persnal, id_rsa_persnal.pub라는 이름의 파일들이 생성된 것을 확인한다. ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:1:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"2. ssh-agent에 ssh-key 등록 $ ssh-add -K ~/.ssh/id_rsa_work $ ssh-add -K ~/.ssh/id_rsa_persnal ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:2:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"3. GitHub에 공개키 등록 로컬에서 생성한 공개키를 복사한다. $ pbcopy \u003c ~/.ssh/id_rsa_work.pub github에 ssh-key에 해당하는 계정으로 로그인 github 계정의 settings - SSH and GPG keys 메뉴를 클릭한다. 3. `New SSH key`를 클릭 4. `title`에는 key에 대한 이름을 지정하고 `key`에 1번에서 복사한 내용을 붙여넣어 준다. 5. 필요한 계정만큼 반복해준다. ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:3:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"4. ssh config $ cd ~/.ssh $ vi config # 없다면 생성 # 아래 내용을 입력 Host github.com-work HostName github.com User work IdentityFile ~/.ssh/id_rsa_work Host github.com-persnal HostName github.com User persnal IdentityFile ~/.ssh/id_rsa_persanl Host : 저장소를 구분하는 일종의 key IdentityFile : ssh-key를 지정 ssh 테스트 해보기 $ ssh -T git@github.com-work Hi {GithubID}! You've successfully authenticated, but GitHub does not provide shell access. 아래 문구가 뜬다면 정상이다. ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:4:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"5. 특정 프로젝트의 git config $ vi {프로젝트}/.git/config ... [user] email = {푸시할 계정의 이메일} git의 global config가 설정되어있는 경우, 위와 같은 설정을 해주어야 해당 계정으로 푸시를 할 수 있음. ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:5:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"6. remote 설정 github에서 git ssh로 clone을 받을 수 있다. : git@github.com-work:work/{프로젝트}.git 또는 이미 remote가 지정되어 있는 상태라면 아래 명령어를 통해 ssh로 바꿀 수 있다. $ git remote set-url origin git@{Host}:{User}/{프로젝트}.git ex. git remote set-url origin git@github.com-work:work/{프로젝트}.git 참고 https://docs.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent https://velog.io/@sonypark/GitHubSSH%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4-%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-%EA%B9%83%ED%97%88%EB%B8%8C-%EA%B3%84%EC%A0%95-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-6mk3iesh0u ","date":"2021-03-08","objectID":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/:6:0","tags":["Git"],"title":"[Git] 동일한 로컬 환경에서 여러개의 깃헙 계정 사용하는 방법","uri":"/%EB%8F%99%EC%9D%BC%ED%95%9C_%EB%A1%9C%EC%BB%AC_%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C_%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98_%EA%B9%83%ED%97%99_%EA%B3%84%EC%A0%95_%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95/"},{"categories":null,"content":"Python의 Docstring과 Annotation에 대한 정리","date":"2021-03-06","objectID":"/docstring%EA%B3%BC_annotation/","tags":["Python"],"title":"[Python]Docstring과Annotation","uri":"/docstring%EA%B3%BC_annotation/"},{"categories":null,"content":"Python의 Docstring과 Annotation에 대한 정리 훌륭한 코드는 그 자체로 (주석이 없어도) 자명하지만 문서화 또한 잘 되어있어야한다. 문서화라고해서 주석이 주렁주렁 달린 코드를 말하는 것이 아닌 문서화를 통해 데이터 타입이 무엇인지 설명하고 때에따라 예제를 제공하는 것을 목표로 한다. ","date":"2021-03-06","objectID":"/docstring%EA%B3%BC_annotation/:0:0","tags":["Python"],"title":"[Python]Docstring과Annotation","uri":"/docstring%EA%B3%BC_annotation/"},{"categories":null,"content":"Docstring Docstring은 소스코드에 포함된 문서라고 말할 수 있으며, 기본적으로 리터럴 문자열로 구성되며 로직의 일부분을 문서화하기 위해 코드 어딘가에 배치된다. 파이썬의 경우 동적 타이핑을 하기 때문에 함수의 입력과 출력을 문서화하여 사용자가 사용할 때 함수가 어떻게 동작하는지 이해하기 쉽게끔 docstring으로 문서화를 하는 것이 코드의 동작을 이해하는데 큰 도움이 될 수 있다. 따라서 Docstring을 아래와 같이 정리해 볼 수 있다. Docstring은 ‘이유’가 아닌 ‘설명’이다. 코드의 특정 컴포넌트(module, class, method, function)에 대한 문서화이다. 가능한 많은 docstring을 추가하는 것이 권장된다. Sphinx(스핑크스)를 실행하여 autodoc 익스텐션을 사용하면 자동으로 문서를 만들 수 있다. Example \u003e\u003e\u003e def my_function(): ... \"\"\" ... 1. 이 함수가 하는 일은 무엇인가요? ... ... 2. 이 함수는 무엇을 입력받나요? ... ... 3. 그래서 최종적으로 이 함수는 무엇을 반환하나요? ... \"\"\" ... pass ... \u003e\u003e\u003e my_function.__doc__ '1. 이 함수가 하는 일은 무엇인가요?\\n \\n 2. 이 함수는 무엇을 입력받나요?\\n \\n 3. 그래서 최종적으로 이 함수는 무엇을 반환하나요?\\n' \"\"\"{docstring}\"\"\" : 리터럴 문자열로 특정 컴포넌트에 대한 문서화를 작성 __doc__ : 해당 속성을 통해 docstring에 접근 가능 # dict.update에 대한 docstring 예제 \u003e\u003e\u003e dict.update.__doc__ 'D.update([E, ]**F) -\u003e None. Update D from dict/iterable E and F.\\n If E is present and has a .keys() method, then does: for k in E: D[k] = E[k]\\n If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v\\n In either case, this is followed by: for k in F: D[k] = F[k]' ","date":"2021-03-06","objectID":"/docstring%EA%B3%BC_annotation/:1:0","tags":["Python"],"title":"[Python]Docstring과Annotation","uri":"/docstring%EA%B3%BC_annotation/"},{"categories":null,"content":"Annotation Python의 경우 동적으로 타입을 결정하기 때문에 함수나 메서드를 거치면서 변수나 객체의 값이 무엇인지 알기가 어려운 경우가 많으므로 어노테이션을 통해 이러한 정보를 명시해준다면 다른 개발자가 코드를 쉽게 이해하는데 도움이 된다. Java에도 Annotation이 존재한다. 그러나 Python에서의 Annotation은 단순히 타입에 대한 힌트를 주는 역할만을 하게된다. (Java의 Annotation은 Python의 Decorator가 비슷한 역할을 한다고 볼 수 있다.) Annotation에 대해 간단히 정리해보면 다음과 같다. 변수의 예상 타입을 지정하여 힌트를 줄 수 있다. (타입 뿐만 아니라 어떤 형태의 메타데이터라도 지정할 수 있다.) annotation정보를 사용하여 문서 생성, 유효성 검증, 타입 체크를 할 수 있다. Example \u003e\u003e\u003e class Point: ... def __init__(self, lat, long): ... self.lat = lat ... self.long = long ... \u003e\u003e\u003e def locate(latitude: float, longitude: float) -\u003e Point: ... \"\"\"맴에서 좌표에 해당하는 객체를 검색\"\"\" ... return Point(latitude, longitude) ... \u003e\u003e\u003e locate.__annotations__ {'latitude': \u003cclass 'float'\u003e, 'longitude': \u003cclass 'float'\u003e, 'return': \u003cclass '__main__.Point'\u003e} # 변수에도 지정 가능 (Python 3.6이상) \u003e\u003e\u003e class Point: ... lat: float ... long: float ... \u003e\u003e\u003e Point.__annotations__ {'lat': \u003cclass 'float'\u003e, 'long': \u003cclass 'float'\u003e} # 타입이 아닌 문자열도 가능 \u003e\u003e\u003e def aa() -\u003e \"리턴\": ... pass ... \u003e\u003e\u003e aa.__annotations__ {'return': '리턴'} : : 함수의 파라미터 및 변수 뒤에 콜론을 이용하여 annotation을 달 수 있다. -\u003e : 함수의 반환값에 대한 annotation을 달 수 있다. __annotations__ : 해당 속성을 통해 annotation에 접근 가능 ","date":"2021-03-06","objectID":"/docstring%EA%B3%BC_annotation/:2:0","tags":["Python"],"title":"[Python]Docstring과Annotation","uri":"/docstring%EA%B3%BC_annotation/"},{"categories":null,"content":"Annotation은 Docstring을 대체? Docstring에 포함된 정보의 일부는 어노테이션으로 이동시킬 수 있는 것은 사실이지만, docstring을 통해 보다 나은 문서화를 위한 여지를 남겨두어야 한다. 동적 데이터 타입과 중첩 데이터 타입의 경우 예상 데이터의 예제를 제공하여 어떤 형태의 데이터를 다루는지 제공하는 것이 좋다는 것이다. def data_from_response(response: dict) -\u003e dict: if response[\"status\"] != 200: raise ValueError return {'data': response[\"payload\"]} 예를들어 위와 같이 데이터의 유효성을 검사하고 dict값을 반환하는 함수를 보면 response객체의 올바른 인스턴스의 형태는 알 수가 없다. 따라서 아래와 같이 이러한 함수에 docstring을 통해 보다 나은 설명을 추가할 수가 있다. def data_from_response(response: dict) -\u003e dict: \"\"\"response에 문제가 없다면 response의 payload를 반환 - response의 예:: { \"status\": 200, # \u003cint\u003e \"payload\": { ... } # 반환하려는 데이터 } - 반환 dict 값의 예:: {\"data\": { ... } } - 발생 가능한 예외: - HTTP status가 200이 아닌 경우 ValueError 발생 \"\"\" if response[\"status\"] != 200: raise ValueError return {'data': response[\"payload\"]} 또한, docstring은 단위 테스테에서도 유용한 정보로 사용될 수 있다. 예를들어, 테스트용 입력 값을 생성할 수도 있고 테스트의 성공 실패를 판단하는 것이다. 간단히 정리를 해보자면, Annotation은 Docstring을 부분적으로 대체를 할 수는 있겠지만, Annotation과 Docstring을 적절히 사용하여 코드의 가독성을 높이고 코드에 대한 문서화를 더욱 보기 좋게 다듬는 것이 중요하다고 할 수 있겠다. ","date":"2021-03-06","objectID":"/docstring%EA%B3%BC_annotation/:3:0","tags":["Python"],"title":"[Python]Docstring과Annotation","uri":"/docstring%EA%B3%BC_annotation/"}]